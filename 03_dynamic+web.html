<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>Fetch 심화</title>
    <style>
      body {
        font-family: sans-serif;
        line-height: 1.6;
        padding: 20px;
      }
      .container {
        max-width: 800px;
        margin: auto;
      }
      .box {
        background-color: #f9f9f9;
        border: 1px solid #ddd;
        padding: 15px;
        margin-bottom: 20px;
        border-radius: 5px;
      }
      h1,
      h2,
      h3 {
        border-bottom: 2px solid #eee;
        padding-bottom: 10px;
      }
      code {
        background-color: #e4e4e4;
        padding: 2px 5px;
        border-radius: 3px;
        font-weight: bold;
      }
      button {
        padding: 10px 15px;
        font-size: 16px;
        cursor: pointer;
        margin-right: 10px;
      }
      #user-card {
        border: 1px solid black;
        padding: 15px;
        margin-top: 10px;
        min-height: 60px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Fetch 심화: DOM, Storage 연동 상세 가이드</h1>

      <div class="box">
        <h2>1. 개념 설명</h2>
        <p>
          이 실습은 <code>fetch</code>를 통해 받아온 데이터를 단순히 출력하는
          것을 넘어, 웹 페이지의 다른 주요 기술들과 연동하는 방법을 다룹니다.
        </p>
        <ul>
          <li>
            <strong>DOM (Document Object Model)</strong>
            <p>
              브라우저가 HTML 문서를 해석하여 JavaScript가 제어할 수 있도록 만든
              <strong>객체 트리 모델</strong>입니다. JavaScript는 DOM을 통해
              HTML 요소의 내용을 읽거나, 스타일을 바꾸거나, 새로운 요소를
              추가/삭제하는 등 페이지를 동적으로 변경할 수 있습니다.
            </p>
          </li>
          <li>
            <strong>BOM (Browser Object Model)</strong>
            <p>
              브라우저의 창, 탭, URL 등 브라우저 자체의 기능들을 JavaScript로
              제어할 수 있게 해주는 객체의 모음입니다.
              <code>window</code> 객체가 최상위에 있으며, 이 예제에서 사용하는
              <code>localStorage</code>도 BOM의 일부입니다.
            </p>
          </li>
          <li>
            <strong>Web Storage API (<code>localStorage</code>)</strong>
            <p>
              웹 브라우저에 데이터를 <strong>영구적으로 저장</strong>할 수 있는
              기술입니다. Key-Value 형태로 데이터를 저장하며, 사용자가 직접
              지우거나 브라우저 캐시를 삭제하지 않는 한 데이터가 사라지지
              않습니다. (창을 닫았다가 다시 열어도 유지됨)
            </p>
          </li>
          <li>
            <strong><code>async / await</code></strong>
            <p>
              Promise 기반의 비동기 코드를 동기 코드처럼 순차적으로 읽고 쓸 수
              있게 해주는 최신 문법입니다. <code>try...catch</code> 구문을
              사용하여 에러를 직관적으로 처리할 수 있어 가독성이 매우
              높아집니다.
            </p>
          </li>
        </ul>
      </div>

      <div class="box">
        <h2>2. 주요 기능/옵션 설명</h2>
        <h3>DOM 제어</h3>
        <ul>
          <li>
            <strong><code>document.getElementById('id')</code></strong
            >: HTML 문서에서 고유한 <code>id</code> 속성을 가진 요소를 찾아
            객체로 반환합니다.
          </li>
          <li>
            <strong><code>element.textContent = '...'</code></strong
            >: 선택된 요소의 텍스트 내용을 변경합니다. HTML 태그를 해석하지 않고
            순수 텍스트로만 취급하여 보안에 유리합니다.
          </li>
        </ul>
        <h3>LocalStorage API</h3>
        <ul>
          <li>
            <strong><code>localStorage.setItem('key', 'value')</code></strong
            >: 데이터를 저장합니다. Key와 Value는 모두
            <strong>문자열</strong> 형태로 저장됩니다.
          </li>
          <li>
            <strong><code>localStorage.getItem('key')</code></strong
            >: 저장된 데이터를 Key를 이용해 불러옵니다. 해당 Key의 데이터가
            없으면 <code>null</code>을 반환합니다.
          </li>
          <li>
            <strong><code>localStorage.removeItem('key')</code></strong
            >: 특정 데이터를 삭제합니다.
          </li>
        </ul>
        <h3>에러 처리</h3>
        <ul>
          <li>
            <strong><code>if (!response.ok)</code></strong
            >: <code>fetch</code>는 네트워크 통신 자체에 실패한 경우에만
            .catch로 에러를 전달합니다. 서버가 404(Not Found)나 500(Server
            Error) 같은 에러 코드를 응답해도 일단은 성공으로 간주합니다. 따라서
            <code>response.ok</code> (응답 코드가 200번대인지 여부)를 직접
            확인하여 서버 에러를 처리하는 로직이 반드시 필요합니다.
          </li>
          <li>
            <strong><code>try...catch</code></strong
            >: <code>await</code>를 사용하는 비동기 코드에서 발생하는 에러를
            잡는 표준적인 방법입니다. <code>try</code> 블록 안에서 에러가
            발생하면 즉시 실행을 멈추고 <code>catch</code> 블록으로 제어가
            넘어갑니다.
          </li>
        </ul>
      </div>

      <div class="box">
        <h2>3. 실제 실습</h2>
        <p>
          <strong>'가져오기'</strong> 버튼을 누르면 API에서 사용자 정보를 받아와
          화면에 표시하고, 이름은 로컬 스토리지에 저장합니다.<br />
          이후 페이지를 새로고침하거나 브라우저를 껐다 켜도
          <strong>'불러오기'</strong> 버튼을 누르면 저장된 이름을 다시 확인할 수
          있습니다.
        </p>
        <button id="fetch-user-btn">사용자 정보 가져와서 저장하기</button>
        <button id="load-user-btn">저장된 사용자 이름 불러오기</button>

        <div id="user-card">
          <p><strong>이름:</strong> <span id="user-name"></span></p>
          <p><strong>이메일:</strong> <span id="user-email"></span></p>
        </div>
      </div>
    </div>

    <script>
      // --- 1. DOM 요소 미리 찾아놓기 ---
      // 스크립트 초반에 필요한 HTML 요소들을 변수에 할당해두면 코드가 깔끔해지고 성능에도 미세하게 이점이 있습니다.
      const fetchBtn = document.getElementById("fetch-user-btn");
      const loadBtn = document.getElementById("load-user-btn");
      const userNameSpan = document.getElementById("user-name");
      const userEmailSpan = document.getElementById("user-email");

      // --- 2. '가져오기' 버튼 클릭 이벤트 처리 ---
      // 'async' 키워드를 붙여 이 함수가 비동기 작업을 포함하고 있음을 알립니다.
      fetchBtn.addEventListener("click", async () => {
        // 'try...catch' 구문으로 비동기 작업 중 발생할 수 있는 에러를 처리합니다.
        try {
          // 'await' 키워드는 fetch 작업(Promise)이 완료될 때까지 코드 실행을 잠시 '기다리게' 합니다.
          // 서버로부터 응답이 오면 그 결과를 response 변수에 담습니다.
          const response = await fetch(
            "https://jsonplaceholder.typicode.com/users/1"
          );

          // 서버 응답 상태가 'ok'(200-299)가 아니면 직접 에러를 발생시켜 catch 블록으로 보냅니다.
          if (!response.ok)
            throw new Error("사용자 정보를 가져올 수 없습니다.");

          // response.json() 역시 Promise를 반환하므로, JSON 파싱이 완료될 때까지 'await'로 기다립니다.
          // 완료되면 파싱된 데이터(JavaScript 객체)가 userData 변수에 담깁니다.
          const userData = await response.json();

          // 2-1. DOM API: 받아온 데이터로 화면 내용(textContent)을 업데이트합니다.
          // 사용자는 이 시점에서 화면의 변화를 눈으로 보게 됩니다.
          userNameSpan.textContent = userData.name;
          userEmailSpan.textContent = userData.email;

          // 2-2. Storage API (BOM): 받아온 데이터 중 'name'을 'username'이라는 키로 로컬 스토리지에 저장합니다.
          // 이 작업은 백그라운드에서 일어나므로 사용자에게 보이지 않습니다.
          localStorage.setItem("username", userData.name);

          // 모든 작업이 성공했음을 사용자에게 알립니다.
          alert(`${userData.name} 님의 정보를 불러와 저장했습니다.`);
        } catch (error) {
          // try 블록 안에서 어떤 종류의 에러든 발생하면 이 코드가 실행됩니다.
          alert(error.message);
        }
      });

      // --- 3. '불러오기' 버튼 클릭 이벤트 처리 ---
      loadBtn.addEventListener("click", () => {
        // Storage API (BOM): 'username'이라는 키로 로컬 스토리지에 저장된 값을 읽어옵니다.
        const savedName = localStorage.getItem("username");

        // 저장된 값이 있는지 확인합니다.
        if (savedName) {
          // 값이 있다면 사용자에게 alert로 보여줍니다.
          alert(`로컬 스토리지에 저장된 이름은 "${savedName}" 입니다.`);
          alert("지우기(테스트용)");
          localStorage.clear();
        } else {
          // getItem()은 값이 없을 경우 null을 반환하므로, 이 경우 사용자에게 데이터가 없음을 알립니다.
          alert("저장된 사용자 이름이 없습니다. 먼저 정보를 가져와주세요.");
        }
      });
    </script>
  </body>
</html>
